# 计算机网络运输层深度剖析与实践指南：基于Kurose & Ross《计算机网络：自顶向下方法》第三章的全面综述

## 1. 核心综述与架构背景

### 1.1 运输层在网络体系结构中的关键地位

在现代计算机网络复杂的协议栈中，运输层（Transport Layer）扮演着承上启下的核心角色，它位于应用层和网络层之间，是理解网络通信逻辑的关键枢纽。根据《计算机网络：自顶向下方法》的体系结构，运输层的根本使命是为运行在不同主机上的**应用进程**提供**逻辑通信**（Logical Communication）服务 1。

这与网络层形成了鲜明的对比与互补。网络层（Network Layer，即IP层）负责的是**主机到主机**（Host-to-Host）的逻辑通信，其关注点在于如何将数据包从源主机路由到目的主机。然而，一台主机上通常同时运行着多个网络应用进程（如Web浏览器、电子邮件客户端、视频流服务等）。仅仅将数据送达主机是不够的，还需要进一步将数据分发给特定的进程。运输层通过对网络层服务的扩展，实现了**进程到进程**（Process-to-Process）的交付。这种从主机级交付到进程级交付的细化，是网络通信从基础设施导向转为应用导向的临界点 1。

从系统设计的角度来看，运输层协议只运行在端系统（End Systems）中，即用户的计算机、服务器或移动设备上，而网络的中间设备（如路由器、链路层交换机）通常只处理到网络层或链路层的数据。这种设计遵循了互联网架构中至关重要的**端到端原则**（End-to-End Principle），将复杂的可靠性保障、流量控制和拥塞控制功能推向网络边缘，从而保持网络核心（Core）的简单与高效。这种架构决策不仅增强了互联网的可扩展性，也使得应用层的创新无需依赖网络核心设备的升级 1。

### 1.2 互联网运输层协议概览：TCP与UDP的双重奏

互联网体系结构为应用层提供了两种截然不同的运输层服务模型，分别对应两个主要协议：用户数据报协议（UDP）和传输控制协议（TCP）。这两种协议的设计哲学代表了网络通信中的两个极端：效率优先与可靠性优先 1。

**UDP（User Datagram Protocol）** 提供的是一种不可靠、无连接的服务。它被视为一种“尽力而为”（Best-Effort）的协议。UDP在IP层的基础上仅仅增加了两项最基本的功能：复用/分用（Multiplexing/Demultiplexing）和差错检测（Error Checking）。它不保证数据报的按序交付，也不保证不丢包。然而，正是这种极简主义设计，使得UDP在实时性要求高、对延迟敏感的应用场景（如DNS查询、实时语音VoIP、在线游戏）中占据了不可替代的地位。UDP没有复杂的连接建立握手过程，也没有为了维持可靠性而进行的重传机制，因此其开销极低，发送速率可以完全由应用层控制 4。

**TCP（Transmission Control Protocol）** 则提供了一种面向连接的、可靠的字节流服务。TCP的设计目标是在不可靠的网络层之上构建一个可靠的传输通道。为了实现这一目标，TCP引入了极其复杂的机制，包括三次握手连接建立、序列号与确认应答、超时重传、流量控制以及拥塞控制。TCP通过拥塞控制机制动态调整发送速率，以避免网络拥塞导致的丢包，这体现了TCP不仅关注端到端的通信质量，还兼顾了整个网络环境的公平性与稳定性。绝大多数互联网核心应用，如HTTP/HTTPS（Web浏览）、SMTP（邮件传输）、FTP（文件传输），都构建在TCP坚实的可靠性基础之上 1。

通过深入剖析Kurose和Ross教材的第三章，本报告将系统性地解构这些协议背后的原理，从最基本的复用分用机制，到构建可靠数据传输（RDT）的理论模型，再到TCP复杂的拥塞控制算法，最后展望QUIC等新兴协议的演进方向。

---

## 2. 运输层服务原语：复用与分用

复用（Multiplexing）与分用（Demultiplexing）是运输层最基础的功能，解决了“最后一公里”的交付问题——即如何将网络层接收到的比特流正确地引导至主机内特定的应用程序 1。

### 2.1 套接字与端口机制

在操作系统内核中，应用进程与网络协议栈之间的交互接口被称为**套接字**（Socket）。套接字可以被形象地比喻为应用进程与网络之间的“门”。应用进程将报文推向套接字，运输层负责将其输送至网络；反之，运输层将接收到的报文段交付给相应的套接字。为了在主机上成百上千个套接字中准确识别目标，运输层引入了**端口号**（Port Number）的概念。

端口号是一个16位的整数，取值范围为0到65535。其中，0到1023号端口被称为**熟知端口**（Well-known Ports），保留给标准的应用层协议使用（如HTTP使用80端口，HTTPS使用443端口）。运输层报文段的头部包含了**源端口号**和**目的端口号**，这两个字段是实现复用与分用的核心依据 1。

- **复用（发送端）：** 源主机的运输层协议从不同的套接字收集数据块，并为每个数据块封装上头部信息（包含端口号），从而生成运输层报文段，然后将这些报文段传递给网络层。
    
- **分用（接收端）：** 接收主机的运输层协议根据报文段头部的信息，将接收到的报文段定向交付给正确的套接字。
    

### 2.2 无连接的多路分用（UDP模型）

在UDP协议中，套接字是由一个二元组来标识的：`(目的IP地址, 目的端口号)`。

这意味着，如果两个UDP报文段具有不同的源IP地址或源端口号，但它们的目的IP地址和目的端口号相同，那么它们将被定向到接收主机上的**同一个**目标套接字。这种机制对服务器端编程模型产生了深远影响。例如，一个运行在端口53上的DNS服务器进程，通常只需要创建一个UDP套接字。所有客户端发来的DNS查询请求，无论来自何方，都会通过这唯一的“门”进入该进程。因此，UDP服务器进程必须在应用层解析报文内部的数据，以识别发送者的身份或维护会话状态（如果需要的话）。这种模型简化了服务器的资源管理，但也要求应用层承担更多的逻辑处理责任 1。

### 2.3 面向连接的多路分用（TCP模型）

与UDP不同，TCP套接字是由一个四元组来唯一标识的：`(源IP地址, 源端口号, 目的IP地址, 目的端口号)`。

这一区别至关重要。在TCP分用过程中，接收主机使用所有这四个值来将报文段定向到相应的套接字。这意味着，即使两个TCP报文段的目标IP和目标端口完全相同（例如都发往Web服务器的80端口），只要它们的源IP或源端口不同，它们就会被定向到**不同**的套接字。

这种机制使得Web服务器能够同时支持成千上万个并发连接。当一个客户端发起连接请求（SYN段）时，服务器的主“欢迎套接字”（Listening Socket）会处理该握手请求，并为这个特定的连接创建一个**新**的连接套接字（Connection Socket）。这个新套接字专门用于与该特定客户端进行通信。因此，在高并发的Web服务器中，可能同时存在数千个绑定在80端口的套接字，但它们各自关联的四元组是唯一的，从而实现了精细的流隔离。这种架构保证了不同用户的数据流在内核层面就是分离的，极大增强了通信的安全性与管理的清晰度 1。

|**特性**|**UDP 分用机制**|**TCP 分用机制**|
|---|---|---|
|**标识符**|二元组 (目的IP, 目的端口)|四元组 (源IP, 源端口, 目的IP, 目的端口)|
|**套接字对应关系**|所有客户端报文汇入同一套接字|每个客户端连接对应一个独立套接字|
|**并发处理模型**|单个套接字处理所有流量，应用层区分|父套接字监听，子套接字处理具体会话|
|**适用场景**|短会话、广播/多播、简单请求应答|长连接、需状态维护、高可靠性交互|

---

## 3. 无连接运输：UDP协议深度解析

UDP（RFC 768）的设计哲学是“少即是多”。它剥离了运输层所有非必要的功能，仅保留了复用/分用和最基本的差错检测。尽管常被误解为“不可靠”而遭到轻视，UDP在现代网络架构中却发挥着不可替代的作用，尤其是在QUIC协议出现后，UDP更是成为了下一代互联网传输的基石 1。

### 3.1 UDP的设计权衡与应用场景

为什么开发者会选择UDP而不是功能强大的TCP？这涉及到一系列的工程权衡：

1. **关于发送什么数据的精细控制：** TCP拥有拥塞控制机制，当网络拥塞时会强制遏制发送速率。而UDP没有这种约束，应用进程可以将数据直接推入网络。对于实时应用（如Zoom会议、在线FPS游戏），哪怕丢几帧画面也比画面卡顿（延迟）要好，因此UDP的“即时发送”特性至关重要 7。
    
2. **无需连接建立（无握手）：** TCP在传输数据前需要三次握手，这至少消耗一个往返时间（RTT）。对于只需一次往返的事务性应用（如DNS查询），TCP的握手开销会将延迟翻倍。UDP的无连接特性使其成为这些场景的首选。
    
3. **无连接状态：** TCP需要在端系统中维护复杂的连接状态（接收缓存、发送缓存、拥塞窗口参数、序列号与确认号等）。UDP则不需要维护这些状态，这使得一台服务器能够支持远超TCP的并发用户数。
    
4. **分组首部开销小：** TCP报文段首部至少20字节，而UDP仅需8字节。在传输小包数据（如物联网传感器数据、语音包）时，UDP的带宽效率显著更高。
    

### 3.2 UDP报文结构与校验和机制

UDP报文段结构极其简单，仅包含四个字段（各2字节）：**源端口号**、**目的端口号**、**长度**和**校验和**。

**UDP校验和（Checksum）** 的计算是本章的一个重要考点，它用于检测报文段在传输过程中是否发生了比特翻转（Bit Errors）。虽然IP层也有校验和，但IP只校验头部，而UDP校验和覆盖了头部和数据部分，提供了端到端的数据完整性检查 7。

#### 3.2.1 校验和计算算法（1s Complement Sum）

UDP计算校验和的方法是将报文段的内容视为16位整数的序列，进行**反码算术求和**。

**计算步骤详解：**

1. **分块：** 将数据划分为16位的字（Word）。
    
2. **求和：** 将这些16位字进行二进制加法运算。
    
3. **回卷（Wrap Around）：** 如果加法产生了最高位（第17位）的进位，必须将这个进位加回到结果的最低位。这一步是反码算术的核心。
    
4. **取反：** 将最终的和进行按位取反（0变1，1变0），得到的结果即为校验和。
    

**接收端验证：** 接收端将收到的所有16位字（包括数据和接收到的校验和）相加。如果没有差错，最终结果应为全1（即1111111111111111）。如果出现任何0，则表明检测到了差错。

案例演示 7：

假设有两个8位字节（为了简化演示）：01010011 和 01100110。

1. 求和：
    
    ```
      01010011
    + 01100110
    ----------
      10111001
    ```
    
2. 假设还有一个字节 `01110100`，继续累加：
    
    ```
      10111001
    + 01110100
    ----------
     100101101 (注意这里产生了第9位溢出)
    ```
    
3. **回卷：** 将溢出的 `1` 加回最低位：
    
    ```
      00101101
    +        1
    ----------
      00101110
    ```
    
4. **取反：** 得到校验和 `11010001`。
    

**局限性分析：** UDP校验和虽然简单，但检错能力有限。例如，如果两个16位字中对应的位同时发生翻转（一个从0变1，另一个从1变0），和可能保持不变，从而导致错误未被检测到。这揭示了运输层提供的是“差错检测”而非“差错纠正”服务。

---

## 4. 可靠数据传输原理（RDT）：从理论到模型

可靠数据传输（Reliable Data Transfer, RDT）是网络通信的核心问题。Kurose和Ross通过构建一系列渐进的模型（rdt 1.0 到 rdt 3.0），抽象地展示了如何在不可靠的信道（Unreliable Channel）上构建可靠的服务。理解这一部分是掌握TCP机制的前提 9。

### 4.1 RDT 1.0：完全可靠信道上的传输

这是一个理想化的模型。假设底层信道完全可靠：既不丢包，也不错位。

- **发送方（Sender）：** 仅需从上层接收数据，打包发送。
    
- **接收方（Receiver）：** 接收数据，解包交付。
    
- **状态机（FSM）：** 极其简单，收发双方各只有一个状态，不需要任何反馈（ACK）机制，因为传输绝对成功 9。
    

### 4.2 RDT 2.0：具有比特差错的信道

现实中的信道（如物理线路）可能受噪声干扰导致比特翻转。

- **新机制：**
    
    - **差错检测（Checksum）：** 让接收方知道数据坏了。
        
    - **肯定确认（ACK）：** 接收方告诉发送方“收到且正确”。
        
    - **否定确认（NAK）：** 接收方告诉发送方“收到但坏了”。
        
    - **重传（Retransmission）：** 收到NAK后，发送方重传数据（ARQ协议，自动重传请求）。
        
- **致命缺陷：** RDT 2.0没有考虑**ACK或NAK分组本身也可能受损**的情况。如果发送方收到了一个乱码的反馈，它不知道是该发送新数据还是重传旧数据。盲目重传会导致接收方收到重复分组，而RDT 2.0无法识别重复 11。
    

### 4.3 RDT 2.1 与 RDT 2.2：处理重复分组

为了解决ACK受损导致的重复分组问题，必须引入**序列号**（Sequence Number）。

- **RDT 2.1：** 发送方给每个分组加上序列号（0或1就足够了，因为是停等协议）。接收方通过检查序列号，判断是新分组还是重传的旧分组。如果收到重复分组，接收方丢弃数据但仍需发送ACK（因为发送方还在等待确认）。
    
- **RDT 2.2：** 这是一个优化版本，去除了NAK。接收方通过对**上一个正确接收的分组**发送ACK来表示对当前分组的否定。例如，如果发送方发了分组1，却收到了对分组0的ACK，这等同于收到了NAK，意味着分组1传输失败，需要重传。TCP正是采用了这种基于ACK的机制 13。
    

### 4.4 RDT 3.0：具有丢包的信道

这是最接近真实互联网环境的模型。信道不仅可能错位，还可能完全**丢包**（数据或ACK丢失）。在丢包情况下，接收方不会有任何反馈，发送方会无限期等待。

- 核心机制：定时器（Countdown Timer）。
    
    发送方在发送数据时启动定时器。如果在设定时间内未收到ACK，则判定为丢包（或延迟过大），触发超时重传。
    
- **冗余数据问题：** 由于超时可能由网络延迟而非丢包引起，重传可能导致接收方收到多份副本。序列号机制在此继续发挥作用，用于去重。
    
- **性能瓶颈：** RDT 3.0是一个**停-等（Stop-and-Wait）**协议。发送方每发一个包就必须停下来等待确认。在长距离、高带宽的网络中，这会导致极低的信道利用率。
    
    - 利用率公式： $U_{sender} = \frac{L/R}{RTT + L/R}$
        
        其中 $L$ 是分组长度，$R$ 是传输速率，$RTT$ 是往返时间。如果 $RTT$ 远大于发送时间 $L/R$，利用率将趋近于0。这推动了流水线协议的发展 10。
        

---

## 5. 流水线机制：GBN与SR协议深度对比

为了突破停-等协议的性能瓶颈，现代运输层协议允许发送方发送多个分组而无需等待确认，这种技术称为**流水线**（Pipelining）。这要求必须增加序列号的范围，并且发送方和接收方都需要设置缓存。主要的两种流水线协议是**回退N步（Go-Back-N, GBN）**和**选择重传（Selective Repeat, SR）** 14。

### 5.1 回退N步（GBN）协议

GBN协议采用“累积确认”机制，极其注重接收方的简化设计。

- **发送窗口（N）：** 允许已发送但未确认的分组数最大为N。窗口随着最早发出的分组被确认而向前滑动。
    
- **累积确认（Cumulative ACK）：** 接收方发送ACK $n$，表示序列号为 $n$ 及**之前所有**的分组都已正确接收。
    
- **接收方逻辑：** GBN接收方没有缓存。如果收到乱序分组（例如期望接收 $n$，但收到了 $n+1$），它会直接**丢弃** $n+1$，并重新发送对 $n-1$ 的ACK。
    
- **重传机制：** 一旦发生超时（通常是针对最早的未确认分组），发送方会重传窗口内**所有**已发送但未确认的分组。这就是“回退N步”名称的由来。
    
- **优缺点：** 接收方逻辑简单，不需要缓存。但在高误码率的网络中，单个分组的丢失会导致大量非必要重传，浪费带宽 16。
    

### 5.2 选择重传（SR）协议

SR协议旨在避免GBN的不必要重传，通过让接收方单独确认每个正确接收的分组。

- **独立确认：** 接收方对每个正确接收的分组单独发送ACK。
    
- **接收方缓存：** 接收方必须缓存乱序到达的分组，直到所有缺失的分组都补齐，才能按序交付给上层。
    
- **发送方逻辑：** 每个分组都有独立的逻辑定时器（或模拟机制）。超时后，**仅重传**该特定分组。
    
- **窗口限制：** 为了避免序列号回绕导致的歧义，SR协议要求窗口大小 $N$ 必须小于或等于序列号空间的一半。否则，接收方可能无法区分是一个新的分组还是上一个窗口的重传分组 14。
    

**表 5-1：GBN与SR协议特性对比**

|**比较维度**|**回退N步 (GBN)**|**选择重传 (SR)**|
|---|---|---|
|**ACK机制**|累积确认 (ACK $n$ 确认 $n$ 及之前所有)|独立确认 (ACK $n$ 仅确认 $n$)|
|**接收方缓存**|不需要 (乱序即丢弃)|需要 (缓存乱序分组)|
|**重传策略**|重传窗口内所有未确认分组|仅重传超时/丢失的特定分组|
|**定时器**|仅需一个 (针对最早未确认分组)|逻辑上每个分组都需要定时器|
|**带宽效率**|低 (出错时大量重传)|高 (仅重传必要数据)|
|**复杂性**|低|高 (需复杂的缓存与定时器管理)|

场景模拟分析：

假设发送窗口大小为4，发送了分组1, 2, 3, 4。其中分组2在网络中丢失。

- **GBN行为：** 接收方收到1，发ACK1。收到3，**丢弃**，重发ACK1。收到4，**丢弃**，重发ACK1。发送方超时后，重传**2, 3, 4**。
    
- **SR行为：** 接收方收到1，发ACK1。收到3，**缓存**，发ACK3。收到4，**缓存**，发ACK4。发送方超时后，仅重传**2**。接收方收到2后，将1, 2, 3, 4一并交付上层。
    

---

## 6. 面向连接的运输：TCP协议深度剖析

TCP协议（RFC 793）是互联网可靠传输的基石。它不仅实现了RDT的所有原理，还针对互联网这种复杂的异构网络环境进行了高度优化。

### 6.1 TCP报文段结构与首部字段

TCP报文段由首部和数据载荷组成。首部通常为20字节，但在包含选项时会更长。

- **序列号（Sequence Number，32位）：** TCP是面向字节流的，序列号指的是该报文段数据部分的**第一个字节**在整个数据流中的字节偏移量，而不是报文段的编号。
    
- **确认号（Acknowledgment Number，32位）：** 期望从对方收到的**下一个字节**的序号。TCP采用**累积确认**。如果主机A收到B发来的确认号500，意味着B已经正确接收了0到499的所有字节。
    
- **接收窗口（Receive Window，16位）：** 用于**流量控制**。指示接收方当前接收缓存中剩余的可用空间大小（字节数），告诉发送方“我还能吃下多少数据”。
    
- **首部长度（4位）：** 指示TCP首部有多少个32位字。因为TCP选项字段长度可变，这个字段是必须的。
    
- **标志位（Flags）：**
    
    - **SYN：** 同步序列号，用于发起连接。
        
    - **FIN：** 结束连接。
        
    - **ACK：** 确认号字段有效。
        
    - **RST：** 重置连接（处理异常情况）。
        
    - **PSH：** 推送功能，提示接收方立即将数据交付应用层。
        
    - **URG：** 紧急指针有效（现在很少使用）。
        

### 6.2 TCP连接管理：三次握手与四次挥手

TCP连接是逻辑上的状态同步，必须在数据传输前建立。

#### 6.2.1 三次握手（Three-Way Handshake）
![[Pasted image 20251227204943.png]]
为何需要三次？主要是为了防止已失效的连接请求报文段突然又传到了服务端，产生错误。

1. **SYN (Client -> Server):** 客户端发送 `SYN=1`，随机选择初始序列号 `client_isn`。此时不携带数据。客户端进入 `SYN_SENT` 状态。
    
2. **SYN+ACK (Server -> Client):** 服务器收到SYN，分配缓存和变量。发送 `SYN=1`, `ACK=1`。确认号设为 `client_isn + 1`，并随机选择服务器的初始序列号 `server_isn`。服务器进入 `SYN_RCVD` 状态。
    
    - _安全隐患：_ 这里存在**SYN Flood攻击**风险。攻击者发送大量SYN但不回复第三次握手，耗尽服务器资源。现代服务器使用SYN Cookie来防御。
        
3. **ACK (Client -> Server):** 客户端收到SYN+ACK，分配缓存。发送 `ACK=1`, `SYN=0`，确认号 `server_isn + 1`。这个报文段**可以携带数据**。连接建立，双方进入 `ESTABLISHED` 状态 19。
    

#### 6.2.2 四次挥手（Connection Termination）
![[Pasted image 20251227205009.png]]
TCP连接是全双工的，每个方向必须单独关闭。

1. **FIN (Client -> Server):** 客户端发送 `FIN=1`，进入 `FIN_WAIT_1`。表示“我没有数据要发了”。
    
2. **ACK (Server -> Client):** 服务器收到FIN，发送ACK。客户端进入 `FIN_WAIT_2`。此时连接处于**半关闭**状态：客户端不能发数据，但能收数据；服务器还能发数据。
    
3. **FIN (Server -> Client):** 服务器数据发完了，发送 `FIN=1`，进入 `LAST_ACK`。
    
4. **ACK (Client -> Server):** 客户端收到FIN，发送ACK，进入 **`TIME_WAIT`** 状态。
    
    - **TIME_WAIT的重要性：** 客户端必须等待 $2 \times MSL$（最大报文段寿命，通常2分钟）。这是为了：(1) 保证最后一个ACK能到达服务器（如果丢了，服务器会重传FIN，客户端需重发ACK）；(2) 确保本连接产生的所有旧报文段在网络中彻底消失，防止干扰下一个使用相同端口的新连接 20。
        

---

## 7. TCP的可靠传输机制：RTT估计与重传

TCP的可靠传输基于超时重传和快速重传，但这需要极其精准的往返时间（RTT）估计。

### 7.1 RTT估计与超时时间计算

如果超时时间设置太短，会造成不必要的重传；太长则反应迟钝，降低效率。TCP采用**指数加权移动平均（EWMA）算法来平滑RTT测量值 。

1. EstimatedRTT（平滑RTT）：
    
    $$EstimatedRTT = (1 - \alpha) \times EstimatedRTT + \alpha \times SampleRTT$$
    
    通常 $\alpha = 0.125$。这意味着新测量值占1/8权重，旧均值占7/8。
    
2. DevRTT（RTT偏差）： 估算RTT的波动幅度。
    
    $$DevRTT = (1 - \beta) \times DevRTT + \beta \times |SampleRTT - EstimatedRTT|$$
    
    通常 $\beta = 0.25$。
    
3. TimeoutInterval（超时时间）：
    
    $$TimeoutInterval = EstimatedRTT + 4 \times DevRTT$$
    
    加上4倍的偏差作为安全裕度，确保只有在网络出现严重延迟或丢包时才触发超时。
    

### 7.2 快速重传（Fast Retransmit）

超时重传的等待时间往往较长。TCP利用冗余ACK（Duplicate ACK）来快速检测丢包。

如果发送方连续收到3个针对同一个报文段的冗余ACK（即共收到4个ACK），这强有力地暗示该报文段后的那个报文段已经丢失，而后续的报文段已经到达（触发了接收方发送冗余ACK）。此时，TCP不等待定时器过期，立即重传丢失的报文段 22。

---

## 8. TCP流量控制与拥塞控制：核心算法

这是TCP最复杂也最迷人的部分。流量控制是点对点的协商，拥塞控制则是端系统对网络整体环境的感知与适应。
![[Pasted image 20251227210548.png]]
### 8.1 流量控制（Flow Control）

目的是防止发送方发得太快，撑爆接收方的接收缓存。

- **机制：** 利用TCP首部中的 `rwnd` 字段。接收方在每个ACK中通告自己剩余的缓存大小。
    
- **公式：** `rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)`
    
- **死锁与解决：** 如果接收方通告 `rwnd=0`，发送方将停止发送。为防止接收方有了空间但发送方不知道（ACK丢失），发送方会启动一个**持续定时器**，定期发送1字节的探测报文（Zero Window Probe），迫使接收方响应当前的窗口值 23。
    

### 8.2 拥塞控制（Congestion Control）

目的是防止过多的数据注入网络，导致路由器缓存溢出和链路拥塞。TCP引入了**拥塞窗口（cwnd）**，发送方实际的发送窗口取值为 $\min(cwnd, rwnd)$。

TCP拥塞控制算法（以经典的Reno版本为例）包含三个阶段 25：

#### 8.2.1 慢启动（Slow Start）

- **原理：** 连接刚建立时，对网络状况一无所知，因此要“试探性”地增加速率，但增长速度是**指数级**的。
    
- **操作：** 初始 `cwnd = 1 MSS`。每收到一个ACK，`cwnd` 加 1 MSS。这意味着每经过一个RTT，`cwnd` 翻倍（1 -> 2 -> 4 -> 8...）。
    
- **结束条件：**
    
    1. 发生超时：`ssthresh` 设为当前 `cwnd` 的一半，`cwnd` 重置为1，重新慢启动。
        
    2. 达到慢启动阈值（`ssthresh`）：进入拥塞避免阶段。
        
    3. 收到3个冗余ACK：进入快速恢复。
        

#### 8.2.2 拥塞避免（Congestion Avoidance）

- **原理：** 当窗口达到阈值，说明可能接近网络极限，改为**线性增长**（加性增，Additive Increase）。
    
- **操作：** 每经过一个RTT，`cwnd` 增加 1 MSS。或者说，每收到一个ACK，`cwnd` 增加 `MSS/cwnd`。这是一种谨慎的探测。
    

#### 8.2.3 快速恢复（Fast Recovery）

这是TCP Reno对TCP Tahoe的重大改进。

- **触发：** 收到3个冗余ACK。这表示网络有拥塞但未完全中断（还能传回ACK）。
    
- **操作：**
    
    1. `ssthresh = cwnd / 2`（乘性减，Multiplicative Decrease）。
        
    2. `cwnd = ssthresh + 3 MSS`（为了抵消那3个冗余ACK）。
        
    3. 重传丢失报文。
        
    4. 如果再收到冗余ACK，`cwnd` 继续增加（允许传输新数据）。
        
    5. 一旦收到**新**数据的ACK，将 `cwnd` 设为 `ssthresh`，进入拥塞避免。
        

**AIMD算法总结：** 总体来看，TCP的行为表现为“加性增，乘性减”（AIMD）。这种锯齿状的窗口变化曲线保证了多个TCP流能公平地共享带宽，并收敛于网络的稳定点。

---

## 9. 运输层的演进：QUIC与HTTP/3

随着互联网的发展，TCP的一些固有缺陷（如队头阻塞、握手延迟）在高延迟和移动网络下愈发明显。Kurose & Ross 第8版引入了QUIC协议的讨论 5。

### 9.1 TCP的局限与QUIC的突破

- **队头阻塞（HOL Blocking）：** 在TCP中，如果一个报文段丢失，后续的所有报文段即使到达了接收缓存也无法交付，必须等待丢失的那个重传成功。这对于多路复用的HTTP/2是致命的。QUIC基于UDP，在应用层实现了独立的流控制，一个流的丢包不会阻塞其他流。
    
- **连接迁移：** 移动设备在Wi-Fi和4G间切换时，IP地址会变，TCP连接会断开。QUIC使用**Connection ID**（CID）标识连接，允许在网络切换时保持连接不断。
    
- **0-RTT 握手：** QUIC将传输层握手与TLS加密握手合并，使得再次连接时可以实现0-RTT发送数据，极大降低了延迟 27。
    

---

## 10. 综合实战题库与解析

为了巩固上述知识点，以下设计了涵盖各个难度的典型试题。

### 题目 1：校验和计算（基础）

问题： 假设UDP报文段的数据部分包含两个16位的字：11100110 01100110 和 11010101 01010101。请计算UDP校验和。

解析：

1. 按二进制加法求和：
    
    ```
      11100110 01100110
    + 11010101 01010101
    -------------------
    1 10111011 10111011 (产生进位)
    ```
    
2. 回卷（将进位加到末尾）：
    
    ```
      10111011 10111011
    +                 1
    -------------------
      10111011 10111100
    ```
    
3. 取反得到校验和：
    
    01000100 01000011
    

### 题目 2：序列号与确认号逻辑（核心）

问题： 主机A向主机B发送两个TCP报文段。

报文段1：序列号Seq=42，数据长度=10字节。

报文段2：序列号Seq=52，数据长度=20字节。

如果报文段1丢失，但报文段2到达了主机B。主机B发回的ACK号是多少？

解析：

- 报文段1占据字节序列 。
    
- 报文段2占据字节序列 。
    
- TCP是累积确认。当主机B收到报文段2时，发现它期望接收的字节42（报文段1的开头）尚未到达，因此出现“空洞”。
    
- 主机B不能确认报文段2，它必须确认**它期望收到的下一个有序字节**。
    
- 因此，主机B发送的ACK号仍然是 **42**。这实际上是一个冗余ACK，提示A重传从42开始的数据。
    

### 题目 3：拥塞窗口演变（进阶）

问题： 设TCP处于拥塞避免阶段，cwnd = 12,000字节，MSS = 1,000字节。

(a) 如果成功收到一个ACK，新的 cwnd 是多少？

(b) 如果随后发生了超时，新的 ssthresh 和 cwnd 是多少？

(c) 如果随后收到了3个冗余ACK（而不是超时），新的 ssthresh 和 cwnd 是多少？

解析：

(a) 拥塞避免增长： 每个ACK增加 MSS * (MSS / cwnd)。

增量 = $1000 \times (1000 / 12000) = 83.33$ 字节。

新 cwnd = 12,083 字节。

(b) 超时处理（Tahoe/Reno通用）：

ssthresh = 当前 cwnd / 2 = 6,000 字节。

cwnd 重置为 1 MSS = 1,000 字节。

进入慢启动。

(c) 快速恢复（Reno）：

ssthresh = 当前 cwnd / 2 = 6,000 字节。

cwnd = ssthresh + 3 MSS = 6,000 + 3,000 = 9,000 字节。

进入快速恢复阶段，重传丢失报文。

---

**结语：** 本报告通过近15,000字的篇幅，从理论模型到协议细节，再到算法推演，全方位解构了计算机网络运输层。建议复习时重点绘制TCP状态机和拥塞控制曲线图，结合上述习题进行演练，以达到融会贯通的境界。