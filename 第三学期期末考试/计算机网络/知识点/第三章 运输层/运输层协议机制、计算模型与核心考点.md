# 计算机网络自顶向下方法第三章：运输层协议机制、计算模型与核心考点深度研究报告

## 1. 绪论：运输层在网络体系中的核心地位与服务模型

在计算机网络的复杂分层体系结构中，运输层（Transport Layer）占据着至关重要的中心地位。它不仅连接了应用层与网络层，更是实现端到端（end-to-end）通信可靠性与效率控制的关键环节。依据《计算机网络：自顶向下方法》的理论框架，运输层的核心任务是为运行在不同主机上的应用进程提供“逻辑通信”（logical communication）。这意味着，从应用程序的角度来看，它们似乎是通过一条直接的物理链路相连，而实际上，数据必须穿过由路由器、链路和交换机组成的复杂网络核心。

运输层协议主要在端系统（end systems）中实现，而非在网络核心的分组交换机（路由器）中运行1。这一设计原则体现了互联网架构的“边缘智能化”理念。网络层（Network Layer，如IP协议）提供了主机到主机（host-to-host）的通信服务，但这是一种“尽力而为”（best-effort）的服务，并不保证数据包的顺序、完整性或必然到达。运输层的职责，特别是在使用传输控制协议（TCP）时，就是要在这种不可靠的网络层基础之上，构建出可靠的、面向进程的通信服务2。

本报告将针对《计算机网络：自顶向下方法》第三章的内容，进行详尽的学术梳理与考点解析。我们将深入探讨用户数据报协议（UDP）与传输控制协议（TCP）的内部机制，重点解构校验和计算、可靠数据传输（rdt）状态机推演、滑动窗口协议的效率分析、TCP序列号与确认号的追踪、往返时间（RTT）的数学估算，以及复杂的拥塞控制窗口演变等计算密集型考点。通过对这些核心知识点的深度剖析，旨在为网络工程领域的专业人士及深入学习者提供一份详实的理论与实践指南。

## 2. 复用与分用：运输层的寻址机制

运输层最基础的功能是将网络层提供的主机间交付服务扩展为运行在主机上的应用程序间的交付服务。这一过程通过复用（Multiplexing）和分用（Demultiplexing）机制实现。

### 2.1 复用与分用的工作原理

- **复用（Multiplexing）：** 在源主机端，运输层协议从不同的套接字（Socket）收集数据块。每个套接字都有唯一的标识符。运输层为每个数据块封装头部信息（Header），其中最关键的是源端口号（Source Port）和目的端口号（Destination Port），从而生成报文段（Segment），并将其传递给网络层1。这种将来自多个应用程序的数据汇聚到单一网络层通道的过程称为复用。
    
- **分用（Demultiplexing）：** 在目的主机端，运输层接收来自网络层的报文段，检查其头部信息，根据端口号将报文段定向交付给正确的套接字2。这类似于邮局将到达同一栋大楼（主机）的信件分发给不同的住户（进程）。
    

### 2.2 UDP与TCP分用机制的本质区别

在考试与实际应用中，区分无连接分用（UDP）与面向连接分用（TCP）是极为重要的考点。两者的核心差异在于标识套接字所需的信息维度不同。

|**特性**|**UDP 分用（无连接）**|**TCP 分用（面向连接）**|
|---|---|---|
|**套接字标识**|**二元组**：(目的IP地址, 目的端口号)|**四元组**：(源IP地址, 源端口号, 目的IP地址, 目的端口号)|
|**连接状态**|无连接状态，每个报文独立处理|维护连接状态，每个连接对应特定的套接字|
|**交付逻辑**|凡是目的IP和目的端口相同的报文，均交付给同一个套接字|只有源IP、源端口、目的IP、目的端口完全匹配的报文，才交付给同一套接字|
|**服务器模型**|单一进程/线程处理所有客户端请求（通常）|为每个客户端连接分配独立的套接字（通常通过fork或多线程）|

#### 2.2.1 UDP分用实例分析

假设主机A（IP: A）上的进程通过端口12345向服务器B（IP: B）的端口80发送UDP报文。同时，主机C（IP: C）上的进程也通过端口6789向服务器B的端口80发送UDP报文。

- **分析：** 服务器B在端口80上运行的UDP进程将拥有一个标识为 `(B, 80)` 的套接字。
    
- **结果：** 来自A和C的报文段，尽管源IP和源端口不同，但只要目的IP是B且目的端口是80，都会被网络层交付给同一个运输层套接字3。服务器程序必须通过读取报文段中的源信息来区分数据来源。
    

#### 2.2.2 TCP分用实例分析

考虑同样的场景，但使用TCP协议。

- **分析：** Web服务器B在端口80上运行。它首先有一个“欢迎套接字”（Listening Socket），专门用于处理连接请求（SYN报文）。
    
- **握手后：** 当主机A与服务器B建立连接后，服务器B会分配一个新的、专门的套接字来标识这条连接，该套接字由四元组 `(A, 12345, B, 80)` 唯一标识。同理，主机C与服务器B建立连接后，会有另一个套接字 `(C, 6789, B, 80)`。
    
- **结果：** 即使两个报文段都到达B的80端口，TCP运输层会根据源IP和源端口的不同，将它们精确地分发给两个完全不同的套接字进程3。这种机制允许服务器并发地与多个客户端进行独立的会话，而不会混淆数据流。
    

## 3. 无连接运输：UDP协议与校验和计算

用户数据报协议（UDP）是一种精简的、“裸机”性质的运输层协议。它在IP协议的基础上仅增加了复用/分用和差错检测功能1。UDP不保证可靠交付，没有流量控制和拥塞控制，因此具有低延迟、头部开销小（仅8字节）的特点，广泛应用于DNS、流媒体和实时游戏等领域。

### 3.1 UDP校验和（Checksum）的计算原理

UDP校验和的计算是第三章中第一个重要的计算题型。其目的是检测报文段在传输过程中是否出现了比特差错（如链路层的噪声导致的位翻转）。

#### 3.1.1 计算步骤与“伪首部”

UDP校验和的计算范围覆盖了三个部分：

1. **伪首部（Pseudo-header）：** 这是一个从IP首部提取信息的临时结构，包含源IP地址、目的IP地址、协议号（UDP为17）和UDP长度。引入伪首部的目的是为了再次确认数据包确实是发往该主机的该协议，防止IP层投递错误4。
    
2. **UDP首部：** 包含源端口、目的端口、长度和校验和字段本身（计算时视为全0）。
    
3. **数据部分：** 应用层数据。如果数据长度为奇数字节，需填充一个全0字节以凑成16位偶数。
    

#### 3.1.2 16位反码求和（16-bit One's Complement Sum）

计算的核心算法是“16位反码求和”。这里的“反码算术”是指在二进制加法中，如果最高位（第16位）产生进位（Carry），则必须将该进位加回到结果的最低位4。这种机制称为**端回卷（End-around Carry）**。

**计算流程：**

1. 将所有内容划分为16位的字序列。
    
2. 对这些16位字进行二进制加法。
    
3. 如果遇到最高位溢出（进位），将溢出的1加到最低位。
    
4. 将最终的和进行**按位取反**（1变0，0变1），得到的结果即为校验和。
    

#### 3.1.3 计算实例演示

假设我们需要计算三个16位字的校验和：

- 字1: `0110011001100000`
    
- 字2: `0101010101010101`
    
- 字3: `1000111100001100`
    

步骤1：前两个字相加

0110011001100000

- 0101010101010101
    

---

1011101110110101

（无进位，直接保留结果）

步骤2：将结果与第三个字相加

1011101110110101

- 1000111100001100
    

---

10100101011000001

注意： 这里产生了第17位的进位（最左边的1）。

步骤3：处理进位（回卷）

将溢出的 1 加到最低位：

0100101011000001

- ```
               1
    ```
    

---

0100101011000010

步骤4：按位取反

将 0100101011000010 取反，得到校验和：

1011010100111101

接收端验证：

接收方将收到的所有16位字（包括数据和接收到的校验和）相加。如果传输过程中无差错，根据反码算术的性质，原码 + 反码 = 全1。因此，接收端的计算结果应为 1111111111111111（即-0）。如果结果中包含任何一个0，则表明检测到了差错7。

这种算法的一个显著优势是**字节序独立性**（Endianness Independence）。无论通信双方是大端序还是小端序，只要遵循相同的加法逻辑，校验结果都是一致的，这极大地简化了异构网络环境下的协议实现8。

## 4. 可靠数据传输原理（RDT）：协议演进与状态机分析

理解可靠数据传输（Reliable Data Transfer, rdt）是掌握运输层的核心。虽然TCP是最终的实现，但理解其背后的理论演进——从rdt 1.0到rdt 3.0——是解决复杂协议逻辑题的基础。这一部分通常通过有限状态机（Finite State Machine, FSM）来描述。

### 4.1 协议演进逻辑

#### 4.1.1 rdt 1.0：经完全可靠信道的传输

假设底层信道完全可靠，没有比特差错，也没有分组丢失。发送方FSM只需等待上层调用，打包发送；接收方FSM只需等待下层数据，解包交付。这是一个理想化的基准模型。

#### 4.1.2 rdt 2.0：经具有比特差错信道的传输

实际信道可能翻转分组中的比特。

- **机制引入：**
    
    - **校验和（Checksum）：** 用于检测差错。
        
    - **肯定确认（ACK）：** 接收方告诉发送方“收到了，没问题”。
        
    - **否定确认（NAK）：** 接收方告诉发送方“出错了，重传”。
        
- **缺陷：** 如果ACK或NAK分组本身受损怎么办？发送方无法知道接收方是想说“好”还是“坏”。简单的重传可能导致**重复分组（Duplicate Packets）**，而接收方无法区分这是新的数据还是旧数据的重传9。
    

#### 4.1.3 rdt 2.1 与 rdt 2.2：解决确认信息受损

为了解决ACK/NAK受损导致的重复分组问题，协议引入了**序列号（Sequence Number）**。

- **rdt 2.1：** 在分组头中增加序列号（0或1）。发送方在收到受损的ACK/NAK时重传当前分组。接收方检查序列号，如果收到的序列号与期望的相同，则是新分组；如果是已接收过的，则是重传，需丢弃但仍需发送ACK。这导致发送方和接收方的FSM状态数翻倍（等待0号及等待1号）9。
    
- **rdt 2.2（无NAK）：** 实际上不需要NAK。接收方可以对**上一个正确接收的分组**发送ACK（带上序列号）。如果发送方发送了分组1，却收到了对分组0的ACK（即重复ACK），它就知道分组1出问题了，需要重传。这是TCP使用重复ACK机制的雏形10。
    

#### 4.1.4 rdt 3.0：经具有比特差错和丢包信道的传输

这是现实网络的模型。除了比特差错，底层信道还可能丢失分组。

- **机制引入：** **倒计数定时器（Countdown Timer）**。
    
- **工作原理：** 发送方每发送一个分组就启动定时器。如果在时间内收到ACK，则终止定时器；如果超时，则重传。这就是著名的**“停-等”（Stop-and-Wait）**协议。
    
- **关键挑战：** 必须正确设定超时时间。太短会导致不必要的重传，太长会导致对丢包反应迟钝。
    

### 4.2 停-等协议的性能计算：信道利用率

rdt 3.0虽然功能正确，但在现代高速网络中性能极低。这是考试中的高频计算点。

#### 4.2.1 计算公式推导

定义符号：

- $L$：分组长度（bits）
    
- $R$：链路传输速率（bps, bits per second）
    
- $RTT$：往返传播延迟（Round Trip Time, seconds）
    

发送一个分组所需的**传输时延（Transmission Delay）**为：

$$d_{trans} = \frac{L}{R}$$

在停-等协议中，发送方发送一个分组后，必须闲置等待，直到一个RTT（加上接收方处理和发送ACK的时间，通常极短可忽略）过去并收到ACK，才能发送下一个分组。因此，发送一个分组的**总周期时间**是 $RTT + d_{trans}$。

发送方利用率（Utilization, $U_{sender}$） 定义为发送方实际忙于将比特推向信道的时间比例：

$$U_{sender} = \frac{\text{有效传输时间}}{\text{总周期时间}} = \frac{d_{trans}}{RTT + d_{trans}} = \frac{L/R}{RTT + L/R}$$

#### 4.2.2 计算实例与瓶颈分析

**题目：** 假设链路带宽 $R = 1 \text{ Gbps} = 10^9 \text{ bps}$，分组大小 $L = 1000 \text{ Bytes} = 8000 \text{ bits}$，往返时延 $RTT = 30 \text{ ms} = 0.03 \text{ s}$。求停-等协议的信道利用率。

1. 计算传输时延：
    
    $$d_{trans} = \frac{8000}{10^9} = 8 \times 10^{-6} \text{ s} = 8 \mu s$$
    
2. 计算利用率：
    
    $$U_{sender} = \frac{0.000008}{0.03 + 0.000008} \approx \frac{0.000008}{0.03} \approx 0.00027$$
    

**结论：** 结果约为 **0.027%**。这意味着在绝大多数时间里（99.97%），昂贵的1Gbps链路是空闲的，发送方在死等ACK。这在长肥管道（Long Fat Network, LFN，即高带宽、高延迟网络）中是不可接受的。这一计算结果直接引出了对**流水线协议（Pipelined Protocols）**的需求12。

## 5. 流水线传输协议：滑动窗口机制与效率优化

为了解决停-等协议的低效问题，允许发送方在等待确认的同时发送多个分组，这种技术称为**流水线（Pipelining）**。实现流水线需要更复杂的序列号范围和缓冲机制，主要有两种协议形式：**回退N步（Go-Back-N, GBN）**和**选择重传（Selective Repeat, SR）**。

### 5.1 流水线技术对利用率的提升

如果允许发送方有 $N$ 个“在途”（in-flight，即已发送但未被确认）的分组，则理论上信道利用率可以提高 $N$ 倍：

$$U_{sender} = \frac{N \times (L/R)}{RTT + L/R}$$

临界值计算：

为了使信道利用率达到100%（即发送方始终在忙碌，链路被填满），窗口大小 $N$ 必须满足：

$$N \times (L/R) \ge RTT + L/R$$

$$N \ge \frac{RTT + L/R}{L/R} = \frac{RTT}{L/R} + 1$$

实际上，$\frac{RTT}{L/R}$ 就是以分组为单位的带宽延迟积（Bandwidth-Delay Product, BDP）。这就是为什么高速网络需要大窗口的原因14。

### 5.2 回退N步（Go-Back-N, GBN）

GBN协议采用**累积确认（Cumulative Acknowledgment）**机制。

- **发送方：** 维护一个大小为 $N$ 的窗口。如果收到ACK(n)，则表示序号n及之前的所有分组都已正确接收。
    
- **接收方：** 极其简单，没有缓存。只接受按序到达的分组。如果收到乱序分组（如收到分组0、1，然后收到3），接收方会丢弃分组3，并重新发送ACK(1)。
    
- **重传机制：** 发送方只有一个定时器，对应最早的未确认分组（基序号）。一旦超时，发送方必须重传**所有**已发送但未确认的分组（即“回退N步”）。
    
- **优点：** 接收方简单。
    
- **缺点：** 在高误码率下，单个丢包会导致大量不必要的重传，浪费带宽16。
    

### 5.3 选择重传（Selective Repeat, SR）

SR协议通过让发送方仅重传那些它怀疑在网络中丢失或受损的分组而避免了不必要的重传。

- **接收方：** 设置缓存，确认所有正确接收的分组，不管其是否按序。
    
- **确认机制：** **独立确认**。接收方对每个正确接收的分组单独发送ACK。
    
- **发送方：** 为每个分组维护独立的定时器（逻辑上）。超时后只重传该分组。
    
- **复杂性：** 需要复杂的窗口逻辑和缓存管理17。
    

### 5.4 窗口大小与序列号空间的数学关系（易错点）

这是一个涉及协议正确性的逻辑考点，被称为**序列号二义性问题（The Dilemma）**。如果序列号空间太小而窗口太大，接收方可能无法区分“新的分组”和“旧分组的重传”。

#### 5.4.1 GBN的约束

对于GBN协议，发送窗口大小 $N$ 和序列号空间大小 $k$（序列号范围 $0 \dots k-1$）必须满足：

$$N \le k - 1$$

这意味着窗口大小必须严格小于序列号空间。如果 $N=k$，接收方无法分辨收到的分组是当前窗口的第0号（新）还是上一窗口的第0号（旧重传）16。

#### 5.4.2 SR的约束

对于SR协议，由于接收方也会缓存乱序分组，约束更为严格。发送窗口 $N_s$ 和接收窗口 $N_r$（通常 $N_s = N_r = N$）必须满足：

$$N_s + N_r \le k$$

通常取 $N_s = N_r = N$，则有：

$$N \le \frac{k}{2}$$

即窗口大小不能超过序列号空间的一半。

场景实例分析19：

假设序列号用2位表示（0, 1, 2, 3），即 $k=4$。若窗口大小 $N=3$（大于 $k/2=2$）。

1. 发送方发送 0, 1, 2。
    
2. 接收方接收 0, 1, 2，缓存并交付，窗口前移，期望 3, 0, 1。
    
3. 接收方回传 ACK 0, ACK 1, ACK 2。
    
4. **灾难场景：** 这些ACK全部丢失。
    
5. 发送方超时，重传分组 0。
    
6. 接收方收到分组 0。由于其期望窗口包含“0”（即下一个循环的0），接收方会**误认为这是一个新的数据分组**并将其缓存。
    
7. 结果：接收方将旧数据的副本作为新数据向上层交付，导致数据错误。
    
    因此，SR协议中窗口大小必须被限制在序列号空间的一半以内，以消除这种二义性。
    

## 6. 面向连接运输：TCP协议架构与报文段结构

传输控制协议（TCP）是互联网的基石，它提供全双工、面向连接、可靠的字节流服务。TCP将应用层数据分割成报文段，是本章计算题的重灾区。

### 6.1 TCP报文段结构核心字段

- **源/目的端口号：** 用于复用/分用。
    
- **序列号（Sequence Number, 32位）：** 报文段中**第一个数据字节**在整个字节流中的位置编号。
    
- **确认号（Acknowledgment Number, 32位）：** 期望从对方收到的**下一个**字节的序号。TCP采用**累积确认**。
    
- **首部长度（4位）：** 以32位字为单位。由于有可选字段，TCP首部长度可变（最小20字节，最大60字节）。
    
- **标志位（Flags）：**
    
    - **ACK：** 确认号有效。
        
    - **SYN：** 同步序列号，用于建立连接。
        
    - **FIN：** 结束传输，用于拆除连接。
        
    - **RST：** 复位连接。
        
- **接收窗口（Receive Window, rwnd）：** 用于流量控制，指示接收方当前的缓冲区剩余空间。
    

### 6.2 序列号（Seq）与确认号（Ack）的生成与演变逻辑

TCP是面向字节的（byte-oriented），这与基于分组的rdt协议不同。**序列号是对字节进行编号，而不是对报文段进行编号。**

#### 6.2.1 序列号消耗规则（考点）

- **数据传输：** 消耗的序列号数量等于数据载荷的字节数。
    
- **控制报文：** **SYN标志**和**FIN标志**各消耗**一个**序列号20。
    
- **纯ACK：** 如果报文段不携带数据且不含SYN/FIN，则**不消耗**序列号。
    

#### 6.2.2 计算实例推演

22

**场景：** 主机A向主机B发送数据。初始序列号（ISN）为185。每个报文段携带171字节数据。

1. **A发送Segment 1:**
    
    - Seq = 185
        
    - 数据涵盖字节：185 到 $185 + 171 - 1 = 355$
        
    - A期待的下一个Seq（若发送下一段）= 356
        
2. **B接收Segment 1，发送ACK:**
    
    - B已收到直到355的所有字节。
        
    - B期望收到356。
        
    - Ack = 356。
        
3. **A发送Segment 2:**
    
    - Seq = 356
        
    - 数据涵盖字节：356 到 $356 + 171 - 1 = 526$
        
4. **A发送Segment 3:**
    
    - Seq = 527
        
    - 数据涵盖字节：527 到 697
        

丢包与乱序场景分析：

假设Segment 2丢失，但Segment 3到达主机B。

- B收到Seq=527的报文，但它期望的是Seq=356。
    
- B检测到乱序（Gap）。B缓存Segment 3（通常实现），但不能确认它。
    
- B**必须**再次发送对Segment 1的确认（因为那是最后一个连续接收的字节末尾）。
    
- **B发送：** Ack = 356。
    
- 这就是**冗余ACK（Duplicate ACK）**。A收到冗余ACK，意味着356号字节可能丢失了。这为后文的快速重传算法埋下了伏笔。
    

## 7. TCP连接管理：建立、拆除与状态机演变

TCP连接管理涉及著名的三次握手和四次挥手过程，其中状态机的变迁（特别是TIME_WAIT状态）是高级考点。

### 7.1 三次握手（Three-Way Handshake）

1. **SYN (Client -> Server):**
    
    - Client选择初始序列号 `client_isn`。
        
    - 报文：`SYN=1, Seq=client_isn`。
        
    - **消耗序列号：1**。
        
    - 状态：SYN_SENT。
        
2. **SYN-ACK (Server -> Client):**
    
    - Server收到SYN，分配缓存。选择自己的初始序列号 `server_isn`。
        
    - 报文：`SYN=1, ACK=1, Seq=server_isn, Ack=client_isn+1`。
        
    - **消耗序列号：1**。
        
    - 状态：SYN_RCVD。
        
3. **ACK (Client -> Server):**
    
    - Client收到SYN-ACK。确认服务器的序列号。
        
    - 报文：`ACK=1, Seq=client_isn+1, Ack=server_isn+1`。
        
    - **不消耗序列号**（若不带数据）。
        
    - 状态：ESTABLISHED。
        

### 7.2 四次挥手与状态机考点

连接拆除需要双方单独关闭发送通道，因此需四次交互（FIN, ACK, FIN, ACK）。

#### 7.2.1 TIME_WAIT 状态的重要性

23

当主动关闭方（假设是Client）发送最后一个ACK后，它不会立即进入CLOSED状态，而是进入**TIME_WAIT**状态。

- **持续时间：** 通常为 **2MSL**（Maximum Segment Lifetime，报文段最大生存时间，通常设为2分钟或30秒）。
    
- **存在原因：**
    
    1. **确保最后一个ACK到达：** 如果Client发送的最后一个ACK丢失，Server会超时重传FIN。如果Client已经CLOSED，将无法响应（或发送RST），导致Server无法正常关闭。TIME_WAIT允许Client重发ACK。
        
    2. **防止旧报文干扰新连接：** 在2MSL期间，网络中所有与该连接相关的“迷途”报文段都会自然消亡。这确保了当相同的四元组（IP/端口）被重用建立新连接时，不会被旧连接的残余数据干扰25。
        

**考试陷阱：** 如果题目问“谁会进入TIME_WAIT状态？”答案是**主动发起关闭的一方**。如果是服务器主动关闭连接，服务器将进入TIME_WAIT。

## 8. TCP可靠传输：RTT估算与超时重传计算

TCP使用超时重传机制来处理丢包。设置正确的超时时间间隔（TimeoutInterval）至关重要。如果太短，会造成不必要的重传；如果太长，会造成对丢包反应滞后。TCP必须动态估算往返时间（RTT）。

### 8.1 指数加权移动平均（EWMA）算法

TCP不直接使用单次测量的SampleRTT，而是维护一个平滑的平均值**EstimatedRTT**。这是典型的低通滤波器设计。

#### 8.1.1 核心公式

27

$$EstimatedRTT_{new} = (1 - \alpha) \times EstimatedRTT_{old} + \alpha \times SampleRTT$$

- 推荐值：$\alpha = 0.125$ ($1/8$)。这意味着新样本的权重较小，旧历史的权重较大，使得估算值比较平稳。
    

此外，TCP还估算RTT的波动幅度（偏差），称为DevRTT：

$$DevRTT_{new} = (1 - \beta) \times DevRTT_{old} + \beta \times |SampleRTT - EstimatedRTT_{old}|$$

- 推荐值：$\beta = 0.25$ ($1/4$)。
    

#### 8.1.2 超时时间（TimeoutInterval）计算

超时时间应设置为 EstimatedRTT 加上 4倍的偏差（安全裕度）：

$$TimeoutInterval = EstimatedRTT + 4 \times DevRTT$$

### 8.2 计算题实战演示

30

题目： 设 $\alpha=0.125, \beta=0.25$。初始状态：$EstimatedRTT = 100 \text{ ms}, DevRTT = 5 \text{ ms}$。

事件： 测量到一个新的 $SampleRTT = 106 \text{ ms}$。求更新后的 TimeoutInterval。

步骤1：更新 EstimatedRTT

$$EstimatedRTT_{new} = 0.875 \times 100 + 0.125 \times 106$$

$$= 87.5 + 13.25 = 100.75 \text{ ms}$$

步骤2：更新 DevRTT

注意：计算偏差时通常使用更新前的 EstimatedRTT（尽管有些变体使用更新后的，但RFC标准倾向于使用旧值计算差值）。

$$Error = |106 - 100| = 6 \text{ ms} \\ DevRTT_{new} = 0.75 \times 5 + 0.25 \times 6 \\ = 3.75 + 1.5 = 5.25 \text{ ms}$$

步骤3：计算 TimeoutInterval

$$TimeoutInterval = 100.75 + 4 \times 5.25$$

$$= 100.75 + 21 = 121.75 \text{ ms}$$

### 8.3 Karn算法

如果发生超时重传，TCP会重发报文段。当收到ACK时，我们无法知道这个ACK是确认原报文还是重传报文。

Karn算法规则： 不使用重传报文段的SampleRTT来更新EstimatedRTT。此外，每次超时，将TimeoutInterval直接加倍（指数退避），直到收集到有效的非重传样本为止。

## 9. TCP流量控制：接收窗口与缓冲区管理

流量控制（Flow Control）的目的是消除发送方使接收方缓存溢出的可能性。这是一个速度匹配服务。

### 9.1 接收窗口（rwnd）

TCP在报文段首部包含一个16位的 Window Size 字段。接收方通过该字段通告其接收缓冲区中可用的剩余空间量（rwnd）。

$$rwnd = \text{RcvBuffer} - (\text{LastByteRcvd} - \text{LastByteRead})$$发送方必须保证：$$\text{LastByteSent} - \text{LastByteAcked} \le rwnd$$

即“在途未确认数据量”不超过“接收方通知的窗口大小”。

### 9.2 零窗口探测与死锁预防

考点： 当 rwnd = 0 时会发生什么？

发送方必须停止发送数据。这引入了一个潜在的死锁风险：接收方缓冲区腾空后，会发送一个 rwnd > 0 的ACK通知发送方。如果这个ACK丢失了，发送方将永远等待，接收方也永远等待。

解决方案： TCP规定，当接收方通告窗口为0时，发送方继续发送零窗口探测报文（Zero Window Probe）。这些报文段只有一个字节的数据。接收方收到后，会返回当前的确认号和窗口值，从而让发送方确知窗口是否已打开。

## 10. TCP拥塞控制：核心算法与窗口演变

这是本章最复杂、最具动态性的部分，也是考试压轴题的常客。拥塞控制与流量控制不同，它是为了防止过多的数据注入网络，导致网络核心（路由器）过载。

### 10.1 拥塞控制的状态机

TCP拥塞控制主要包含三个阶段，通过拥塞窗口（cwnd）的调整来实现：

1. **慢启动（Slow Start, SS）**
    
2. **拥塞避免（Congestion Avoidance, CA）**
    
3. **快速恢复（Fast Recovery, FR）**（TCP Reno特有）
    

发送方的实际发送速率受限于：$\min(cwnd, rwnd)$。假设rwnd足够大，主要看cwnd。

#### 10.1.1 慢启动 (Slow Start)

- **初始：** `cwnd = 1 MSS` (Maximum Segment Size)。
    
- **增长：** 每收到一个ACK，`cwnd += 1 MSS`。
    
- **效果：** 每个RTT，cwnd翻倍（1, 2, 4, 8...）。呈**指数增长**。
    
- **终止条件：**
    
    1. 发生超时。
        
    2. 达到慢启动阈值（`ssthresh`）。
        

#### 10.1.2 拥塞避免 (Congestion Avoidance)

- **条件：** 当 `cwnd >= ssthresh` 时进入。
    
- **增长：** 每个RTT，`cwnd += 1 MSS`（实际上是每收到一个ACK，`cwnd += 1/cwnd`）。
    
- **效果：** **线性增长**（加性增，Additive Increase）。
    

#### 10.1.3 丢包事件的处理：Tahoe vs Reno

这是区分TCP版本的关键31。

**事件A：超时（Timeout）**

- **严重性：** 极高。意味着网络可能严重拥塞，连ACK都回不来。
    
- **反应（Tahoe & Reno通用）：**
    
    1. `ssthresh` 设为当前 `cwnd` 的一半：$ssthresh = cwnd / 2$（最小为2）。
        
    2. `cwnd` 重置为 **1 MSS**。
        
    3. 重新进入**慢启动**。
        

**事件B：收到3个冗余ACK（3 Duplicate ACKs）**

- **严重性：** 中等。意味着虽然有丢包，但后续报文段仍能到达接收方（触发了冗余ACK），网络还具有一定的传输能力。
    
- **TCP Tahoe：** 处理方式同超时。粗暴地将cwnd设为1，进入慢启动。
    
- **TCP Reno：** 执行**快速重传（Fast Retransmit）**和**快速恢复（Fast Recovery）**。
    
    1. 执行快速重传：立即重传丢失的报文段，不等待定时器。
        
    2. `ssthresh = cwnd / 2`。
        
    3. `cwnd = ssthresh + 3 MSS`（人为扩大窗口，加上3个已离开网络被缓存的报文段）。
        
    4. 进入**快速恢复**状态。
        

#### 10.1.4 快速恢复 (Fast Recovery)

在Reno中，进入此状态后：

- 每收到一个重复ACK，`cwnd += 1 MSS`（允许发送新数据，维持管道的数据流）。
    
- 当收到**新数据的ACK**（Full ACK）时，说明恢复结束。将 `cwnd` 设为 `ssthresh`（即那时的减半值），进入**拥塞避免**状态。
    

### 10.2 拥塞窗口演变曲线的图形分析技巧

33

考试常给出一个 `cwnd` 随时间（传输轮次）变化的折线图，要求分析特定时刻的状态和事件。

**解题步骤：**

1. **识别指数增长区：** 只要曲线呈陡峭的倍增形态（1, 2, 4, 8），即为**慢启动**。
    
2. **识别线性增长区：** 曲线斜率变缓，呈直线慢速上升，即为**拥塞避免**。
    
3. **识别转折点（ssthresh）：** 慢启动转为拥塞避免的那个cwnd值，就是当前的 `ssthresh`。
    
4. **识别丢包类型：**
    
    - **悬崖式下跌（cwnd骤降为1）：** 发生了**超时**。新的 `ssthresh` 是下跌前高度的一半。
        
    - **折半式下跌（cwnd降为一半左右，然后线性增长）：** 发生了**3个冗余ACK**（Reno行为）。
        

## 11. 运输层性能分析：吞吐量模型与长肥管道

### 11.1 TCP平均吞吐量公式（Mathis Equation）

对于长期的TCP连接，假设只发生由3个冗余ACK引起的丢包（Reno模式），其吞吐量可以由著名的平方根公式（Mathis Equation）描述35：

$$\text{Throughput} \approx \frac{1.22 \times MSS}{RTT \times \sqrt{L}}$$

其中 $L$ 是丢包率（Loss rate）。

深度洞察：

该公式揭示了TCP吞吐量与丢包率的平方根成反比。

- 如果丢包率 $L$ 从 $10^{-4}$ 增加到 $10^{-2}$（增加100倍），吞吐量将下降 $\sqrt{100}=10$ 倍。
    
- 这解释了为什么在高带宽但高误码率（如早期无线网络）的环境中，TCP性能极差。
    

### 11.2 带宽延迟积（BDP）与窗口缩放

**计算题：** 在一条 10 Gbps ($10^{10}$ bps), 100 ms ($0.1$ s) RTT 的光缆上，要跑满带宽，TCP窗口至少需要多大？

计算 BDP：

$$BDP = \text{Bandwidth} \times RTT = 10^{10} \times 0.1 = 10^9 \text{ bits}$$

$$10^9 / 8 \approx 125 \text{ MB}$$

窗口缩放选项（Window Scale Option）：

TCP首部的 Window Size 字段只有16位，最大表示 $2^{16}-1 = 65535$ 字节（约64KB）。这远小于125MB。如果仅使用默认窗口，利用率将极低：

$$\text{Utilization} = \frac{64 \text{ KB}}{125 \text{ MB}} \approx 0.05\%$$

解决方案： RFC 1323 引入了窗口缩放选项。在三次握手期间（仅在SYN包中），双方协商一个移位因子（Shift Count, S）。实际窗口大小计算为：

$$\text{Actual Window} = \text{Header Window Value} \times 2^S$$

最大移位因子为14，使得TCP窗口最大可达1GB（$65535 \times 2^{14}$），从而能够填充现代的长肥管道37。

## 12. 结论

通过对《计算机网络：自顶向下方法》第三章的深入剖析，我们可以看到运输层是网络协议栈中逻辑最为严密、机制最为复杂的部分。从UDP的简单高效到TCP的精细控制，每一项设计——无论是校验和的反码算术、滑动窗口的序号约束，还是RTT估算的平滑滤波、拥塞控制的AIMD法则——都是为了在不可靠的底层网络之上构建可靠通信服务的数学与工程结晶。

对于学习者与从业者而言，掌握这些计算模型（校验和、利用率、RTT、吞吐量）不仅是应对考试的需要，更是理解网络性能瓶颈、进行网络调优与故障排查（Troubleshooting）的理论基石。理解TCP为何在特定丢包率下表现不佳，或者为何在长距离传输中需要调整窗口缩放参数，正是从“网络管理员”进阶为“网络架构师”的关键所在。